"use strict";(globalThis.webpackChunkvbrowser_documentation=globalThis.webpackChunkvbrowser_documentation||[]).push([[38],{8453(e,n,i){i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}},9968(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"usage/idle-timeouts","title":"Idle Timeouts","description":"Idle timeouts in Open vBrowser (OvB) are a core safety and cost-control mechanism. They ensure that browser sessions do not remain active indefinitely when not in use, reducing attack surface and preventing unnecessary cloud spend.","source":"@site/docs/usage/idle-timeouts.md","sourceDirName":"usage","slug":"/usage/idle-timeouts","permalink":"/docs/usage/idle-timeouts","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"File Management","permalink":"/docs/usage/file-management"},"next":{"title":"API","permalink":"/docs/usage/api"}}');var r=i(4848),t=i(8453);const l={sidebar_position:6},o="Idle Timeouts",d={},a=[{value:"Purpose of Idle Timeouts",id:"purpose-of-idle-timeouts",level:2},{value:"How Idle Time Is Measured",id:"how-idle-time-is-measured",level:2},{value:"Configuration Variable",id:"configuration-variable",level:2},{value:"Idle Timeout Behavior",id:"idle-timeout-behavior",level:2},{value:"Manual vs Automatic Termination",id:"manual-vs-automatic-termination",level:2},{value:"Security Implications",id:"security-implications",level:2},{value:"Operational Considerations",id:"operational-considerations",level:2},{value:"Failure Scenarios",id:"failure-scenarios",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"idle-timeouts",children:"Idle Timeouts"})}),"\n",(0,r.jsxs)(n.p,{children:["Idle timeouts in Open vBrowser (OvB) are a ",(0,r.jsx)(n.strong,{children:"core safety and cost-control mechanism"}),". They ensure that browser sessions do not remain active indefinitely when not in use, reducing attack surface and preventing unnecessary cloud spend."]}),"\n",(0,r.jsxs)(n.p,{children:["This document explains ",(0,r.jsx)(n.strong,{children:"how idle timeouts work"}),", ",(0,r.jsx)(n.strong,{children:"how they are configured"}),", and ",(0,r.jsx)(n.strong,{children:"what operators should expect"}),"."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"purpose-of-idle-timeouts",children:"Purpose of Idle Timeouts"}),"\n",(0,r.jsx)(n.p,{children:"Idle timeouts exist to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically terminate unused sessions"}),"\n",(0,r.jsx)(n.li,{children:"Reduce exposure to long-lived compromises"}),"\n",(0,r.jsx)(n.li,{children:"Prevent forgotten active browsers"}),"\n",(0,r.jsx)(n.li,{children:"Control infrastructure costs"}),"\n",(0,r.jsx)(n.li,{children:"Enforce ephemeral usage patterns"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Idle timeouts are ",(0,r.jsx)(n.strong,{children:"enabled by default"})," and should not be disabled."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"how-idle-time-is-measured",children:"How Idle Time Is Measured"}),"\n",(0,r.jsx)(n.p,{children:"Idle time is measured per session based on:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lack of user interaction"}),"\n",(0,r.jsx)(n.li,{children:"Absence of browser activity signals"}),"\n",(0,r.jsx)(n.li,{children:"No active session events"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each session tracks its own idle timer independently."}),"\n",(0,r.jsx)(n.p,{children:"Idle detection is handled by the backend, not the browser."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"configuration-variable",children:"Configuration Variable"}),"\n",(0,r.jsx)(n.p,{children:"Idle timeout behavior is controlled by a single environment variable:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"DEFAULT_IDLE_THRESHOLD\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Value is expressed in ",(0,r.jsx)(n.strong,{children:"minutes"})]}),"\n",(0,r.jsx)(n.li,{children:"Applies globally to all sessions"}),"\n",(0,r.jsx)(n.li,{children:"Must be a positive integer"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"DEFAULT_IDLE_THRESHOLD=10\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This configuration is written to ",(0,r.jsx)(n.code,{children:".env"})," during setup."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"idle-timeout-behavior",children:"Idle Timeout Behavior"}),"\n",(0,r.jsx)(n.p,{children:"When the idle threshold is reached:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"The backend marks the session as idle"}),"\n",(0,r.jsx)(n.li,{children:"The ECS task is stopped"}),"\n",(0,r.jsx)(n.li,{children:"The browser container is destroyed"}),"\n",(0,r.jsx)(n.li,{children:"All session state is lost"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"There is no warning or grace period."}),"\n",(0,r.jsx)(n.p,{children:"Termination is immediate."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"manual-vs-automatic-termination",children:"Manual vs Automatic Termination"}),"\n",(0,r.jsx)(n.p,{children:"Idle timeouts are distinct from manual termination:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Idle timeout"}),": Automatic, inactivity-based"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manual termination"}),": User or admin initiated"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Both result in identical destruction behavior."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"security-implications",children:"Security Implications"}),"\n",(0,r.jsx)(n.p,{children:"Idle timeouts significantly improve security by:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Limiting dwell time for compromised sessions"}),"\n",(0,r.jsx)(n.li,{children:"Reducing persistence opportunities"}),"\n",(0,r.jsx)(n.li,{children:"Preventing long-running browser exploits"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Shorter idle thresholds reduce risk but may impact usability."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"operational-considerations",children:"Operational Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Operators should consider:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Investigation workflows"}),"\n",(0,r.jsx)(n.li,{children:"Analyst interaction patterns"}),"\n",(0,r.jsx)(n.li,{children:"Cost sensitivity"}),"\n",(0,r.jsx)(n.li,{children:"Risk tolerance"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Recommended values:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"5\u201315 minutes"})," for most environments"]}),"\n",(0,r.jsx)(n.li,{children:"Higher values only when necessary"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"failure-scenarios",children:"Failure Scenarios"}),"\n",(0,r.jsx)(n.p,{children:"Idle timeouts may not trigger if:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Backend services are unavailable"}),"\n",(0,r.jsx)(n.li,{children:"Infrastructure is misconfigured"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In such cases:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sessions may persist longer than intended"}),"\n",(0,r.jsx)(n.li,{children:"Teardown should be performed"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Idle timeouts are a control, not a guarantee."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.p,{children:"Recommended practices:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep idle thresholds conservative"}),"\n",(0,r.jsx)(n.li,{children:"Monitor session lifecycle events"}),"\n",(0,r.jsx)(n.li,{children:"Tear down environments when not in use"}),"\n",(0,r.jsx)(n.li,{children:"Treat idle timeouts as a backstop, not primary control"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"To understand how session activity is logged:"}),"\n",(0,r.jsxs)(n.p,{children:["Continue to ",(0,r.jsx)(n.strong,{children:"API"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);